1) String gets converted to array of ascii table byte values
2) Int array made of size x.
	0 <= str <= 55      x = 16 size: 56
	56 <= str <= 119    x = 32 size: 64
	120 <= str <= 183   x = 48 size: 64
	184 <= str <= 247   x = 64 size: 64
	248 <= str <= 311   x = 80 size: 64
0-55 has size 56, all rest have 64





(((i + 8) >> 6) + 1) * 16

This should be thought of as (((i + 9 - 1) >> 6) + 1) * 16
because 9 bytes are added to the message to make it 64 bytes in length total.  1 is subtracted from i because 64 is the 65th element in binary, so an extra diget is required, which will show up on (i >> 6) + 1.  64 items (bytes) can fit into our bucket of size 64.  In binary, the number 64 cannot fit into a bucket of size 64, as the number 64 is the 65th number that can be expressed in binary.


The following for loop simply concatenates all 4 characters (4 bytes) to a long 32 bit string, and places it into block[0], then repeats for all blocks, until messsage is gone.


i is incremented one more time, and 0x80 is appended.  Then the length is simply added at the end.  It looks like this java program only takes lengths of up to 32 bits, since only the last block (4 bytes each) is changed.  TODO: view the blks[] before and after values are updated.

https://shattered.io/static/shattered.pdf
https://www.rfc-editor.org/rfc/pdfrfc/rfc3174.txt.pdf
http://www.cs.haifa.ac.il/~orrd/HashFuncSeminar/Lecture2.pdf
https://en.wikipedia.org/wiki/SHA-1#Examples_and_pseudocode

3c570feb141398bb552ef5a0a82be331fea48037b8b5d71f0e332edf93ac3500eb4ddc0decc1a864790c782c76215660dd309791d06bd0af3f98cda4bc4629b1


Java seems to use a 32 bit sized binary setup.  This means that a binary number that is 32 bits long and starts with a 1 will be a negative number, using the the two's compliment of the negative.  >> and >>> denote signed and unsiged operations respectively.  >> will append another 1 at the start of a negative number to ensure that sign is preserved?

rol() stands for rotate left.  This is done to preserve the information left inside of the arguments but jumbles it up.
	>> will arithmetically shift right wile preserving sign
	>>> will logically shift right, regardless of sign, and simply add 0s on the left hand side (doesn't actually show up as 0s).  This is the desired result, because during a rotation, don't want to introduce extra 1s to the 0s generated by <<.

THIS IS COOL!
	The initial values for h0 (aka A0, B0, C0, D0, E0) are just the big endian version of a little endian 4 bit counter starting at 0000 and ending at 1111, then the reverse of that.  For E0, it is an incrementing counter from 1100 for odd 4-bit groups, and a decrementing counter from 0011 for even groups.
	The values for k_t%20 are simply the didgets of sqrt(2,3,5,10).  Sqrt(7) not taken simply because the value wasn't listed in some book.
	The whole point is that these starting values are trivial and are unlikely to be chosen with some special property in mind.

https://math.stackexchange.com/questions/1348365/expected-number-of-drawings-to-find-collision
https://en.wikipedia.org/wiki/Birthday_attack
https://en.wikipedia.org/wiki/Collision_attack

https://en.wikipedia.org/wiki/Expected_value
https://math.stackexchange.com/questions/846101/expected-value-equals-sum-of-probabilities
https://math.stackexchange.com/questions/843845/find-the-mean-for-non-negative-integer-valued-random-variable



